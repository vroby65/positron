#!/usr/bin/env python3
"""
Positron: a tiny "Electron-like" wrapper using pywebview.

Features:
- Serves ./www at http://127.0.0.1:7000 (stable origin)
- Title = POSITRON_TITLE (env) or executable basename
- Persistent storage per bundle (cookies/localStorage/IndexedDB)
- Window opts: --size, --min-size, --pos, --fullscreen, --fixed, --gui
- Download helper: polling watcher with overwrite confirmation
"""

from __future__ import annotations
import os
import sys
import time
import socket
import shutil
import threading
import argparse
import subprocess
from http.server import ThreadingHTTPServer, SimpleHTTPRequestHandler
from pathlib import Path
import webview

HOST = "127.0.0.1"
PORT = 7000

# ----------------- small utilities -------------------------------------------
def parse_size(s: str):
    """Parse a WIDTHxHEIGHT string and return (w, h)."""
    try:
        w, h = s.lower().split("x")
        w, h = int(w), int(h)
        if w < 100 or h < 100:
            raise ValueError
        return (w, h)
    except Exception as exc:
        raise argparse.ArgumentTypeError(
            "Expected: WIDTHxHEIGHT (e.g. 1200x800)"
        ) from exc

def parse_pos(s: str):
    """Parse an X,Y string and return (x, y)."""
    try:
        x, y = s.split(",")
        return (int(x), int(y))
    except Exception as exc:
        raise argparse.ArgumentTypeError(
            "Expected: X,Y (e.g. 100,50)"
        ) from exc

def wait_for_server(host: str, port: int, timeout: float = 5.0) -> bool:
    """Wait until a server responds within the timeout."""
    deadline = time.time() + timeout
    while time.time() < deadline:
        with socket.socket() as s:
            s.settimeout(0.25)
            try:
                s.connect((host, port))
                return True
            except OSError:
                time.sleep(0.1)
    return False

def start_http_server(root: Path, host: str, port: int,
    no_cache: bool = False) -> ThreadingHTTPServer:
    """Start an HTTP server serving files from root."""
    class Handler(SimpleHTTPRequestHandler):
        """Custom HTTP request handler for Positron."""
        def __init__(self, *args, **kwargs):
            super().__init__(*args, directory=str(root), **kwargs)

        def log_message(self, fmt, *args):  # pylint: disable=arguments-differ
            sys.stdout.write(f"[http] {self.address_string()} - " + (fmt % args) + "\n")

        def end_headers(self):
            if no_cache:
                self.send_header("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0")
                self.send_header("Pragma", "no-cache")
                self.send_header("Expires", "0")
            super().end_headers()

    httpd = ThreadingHTTPServer((host, port), Handler)
    httpd.daemon_threads = True
    threading.Thread(target=httpd.serve_forever, name="positron-http", daemon=True).start()
    return httpd

def ensure_default_index(www_dir: Path) -> None:
    """Ensure www_dir contains a default index.html page."""
    index = www_dir / "index.html"
    if index.exists():
        return
    index.write_text(
        """<!doctype html>
<meta charset="utf-8"><title>Positron</title>
<style>
  :root{color-scheme:light dark}body{font:16px/1.5 system-ui;margin:2rem;max-width:60ch}
</style>
<h1>Positron is alive ✨</h1>
<p>This page is served from <code>./www</code>. Edit <code>www/index.html</code>.</p>
<p id="ls"></p>
<script>
  const n = +(localStorage.getItem("visits")||0) + 1;
  localStorage.setItem("visits", n);
  document.getElementById("ls").innerHTML = "Visits (localStorage): <b>"+n+"</b>";
</script>""",
        encoding="utf-8",
    )

# ----------------- persistence setup ------------------------------------------
_PERSISTENCE_SETUP_DONE = False
_LAST_STORAGE_DIR: Path

def _enable_webkitgtk_settings(native_webview) -> bool:
    """Enable useful WebKitGTK settings if available."""
    changed = False
    try:
        settings = native_webview.get_settings()
        for prop in ("enable-indexed-database", "enable-local-storage"):
            try:
                current = settings.get_property(prop)
                if not current:
                    settings.set_property(prop, True)
                    changed = True
                    print(f"[positron] WebKitGTK setting '{prop}' -> True")
            except Exception: # pylint: disable=broad-exception-caught
                pass
        try:
            settings.set_property("enable-developer-extras", True)
        except Exception: # pylint: disable=broad-exception-caught
            pass
    except Exception as e:
        print(f"[positron] WebKitGTK settings tweak skipped: {e}")
    return changed

def _pin_qt_profile(storage_dir: Path, window: "webview.Window") -> None:
    """Configure persistent Qt WebEngine profile for storage and cookies."""
    try:
        native = getattr(window, "native", None)
        if not native:
            return
        page = native.webview.page()
        profile = page.profile() if callable(getattr(page, "profile", None)) else page.profile
        q_data = str(storage_dir / "qt-profile")
        q_cache = str(storage_dir / "qt-cache")
        profile.setPersistentStoragePath(q_data)
        profile.setCachePath(q_cache)
        try:
            from PyQt5.QtWebEngineWidgets import QWebEngineProfile as _QEP  # type: ignore  # pylint: disable=import-error,no-name-in-module,import-outside-toplevel
            profile.setPersistentCookiesPolicy(_QEP.ForcePersistentCookies)
        except Exception: # pylint: disable=broad-exception-caught
            try:
                from PySide6.QtWebEngineCore import QWebEngineProfile as _QEP  # type: ignore
                profile.setPersistentCookiesPolicy(_QEP.ForcePersistentCookies)
            except Exception: # pylint: disable=broad-exception-caught
                pass
        print(f"[positron] Qt profile pinned -> data={q_data} cache={q_cache}")
    except Exception as e:
        print(f"[positron] Qt profile pin skipped: {e}")

def _infer_backend(window: "webview.Window") -> str:
    """Infer the backend type (gtk or qt) from a webview window."""
    try:
        native = getattr(window, "native", None)
        if not native:
            return ""
        wv = getattr(native, "webview", None)
        if not wv:
            return ""
        if hasattr(wv, "get_settings"):
            return "gtk"
        if hasattr(wv, "page"):
            try:
                _ = wv.page()
                return "qt"
            except Exception:  # pylint: disable=broad-exception-caught
                pass
    except Exception:  # pylint: disable=broad-exception-caught
        pass
    return ""

def _setup_persistence(renderer_hint: str | None, window: "webview.Window",
    storage_dir: Path) -> bool:
    """Set up persistent storage for the given webview backend."""
    global _PERSISTENCE_SETUP_DONE # pylint: disable=global-statement
    if _PERSISTENCE_SETUP_DONE:
        return False
    _PERSISTENCE_SETUP_DONE = True

    r = (renderer_hint or "").lower()
    try:
        active = getattr(webview, "guilib", "") or ""
        if active:
            r = active.lower()
    except Exception:  # pylint: disable=broad-exception-caught
        pass

    if not r:
        r = _infer_backend(window)

    print(f"[positron] persistence setup for backend='{r}' storage_path={storage_dir}")

    try:
        native = getattr(window, "native", None)
        if not native:
            print("[positron] native view not available yet")
            return False

        if "qt" in r:
            _pin_qt_profile(storage_dir, window)
            return False
        elif ("gtk" in r) or ("webkit" in r):
            changed = _enable_webkitgtk_settings(native.webview)
            if changed:
                try:
                    native.webview.reload()
                    print("[positron] WebKitGTK settings applied -> reload")
                    return True
                except Exception as e:  # pylint: disable=broad-exception-caught
                    print(f"[positron] reload failed after settings: {e}")
            return False
        else:
            print("[positron] other backend -> rely on storage_path")
            return False
    except Exception as e:  # pylint: disable=broad-exception-caught
        print(f"[positron] persistence setup failed: {e}")
        return False

def on_loaded(window: "webview.Window"):
    """Callback executed when the webview window is loaded."""
    try:
        reloaded = _setup_persistence(os.environ.get("PYWEBVIEW_GUI"), window, _LAST_STORAGE_DIR)
        if reloaded:
            return
    except Exception as e:  # pylint: disable=broad-exception-caught
        print(f"[positron] persistence (late) error: {e}")

# ----------------- download helper --------------------------------------------
TEMP_EXTS = (".crdownload", ".part", ".partial", ".download", ".tmp")

def detect_download_dir() -> Path:
    """Detect the default Downloads directory for the current platform."""
    if sys.platform.startswith("linux"):
        try:
            out = subprocess.check_output(
                ["xdg-user-dir", "DOWNLOAD"],
                text=True,
                stderr=subprocess.DEVNULL
            ).strip()
            if out and Path(out).exists():
                return Path(out)
        except Exception:  # pylint: disable=broad-exception-caught
            pass
        return Path.home() / "Downloads"

    if sys.platform.startswith("win"):
        return Path(
            os.path.join(
                os.environ.get("USERPROFILE", str(Path.home())),
                "Downloads"
            )
        )

    return Path.home() / "Downloads"

def is_temp_file(path: Path) -> bool:
    """Return True if the file looks like a temporary file."""
    n = path.name.lower()
    if any(n.endswith(ext) for ext in TEMP_EXTS):
        return True
    if n.startswith(".") and (n.endswith(".part") or n.endswith(".tmp")):
        return True
    return False

def choose_save_as(window: "webview.Window", default_name: str, start_dir: Path) -> Path | None:
    """Open a save-as dialog and return the chosen path or None."""
    try:
        res = window.create_file_dialog(
            webview.SAVE_DIALOG,
            directory=str(start_dir),
            save_filename=default_name
        )
        if not res:
            return None
        if isinstance(res, (list, tuple)):
            return Path(res[0])
        return Path(res)
    except Exception as e:  # pylint: disable=broad-exception-caught
        print(f"[positron] Save-as dialog error: {e}")
        return None

def list_finished(dirpath: Path) -> set[str]:
    """Return a set of finished files in dirpath (ignoring temp files)."""
    try:
        return {
            entry.name
            for entry in os.scandir(dirpath)
            if entry.is_file(follow_symlinks=False) and not is_temp_file(Path(entry.name))
        }
    except FileNotFoundError:
        return set()

def wait_file_stable(p: Path, stable_secs: float = 0.8, timeout: float = 300.0) -> bool:
    """Wait until file size stays stable for stable_secs or until timeout."""
    start = time.time()
    try:
        last = os.stat(p).st_size
    except FileNotFoundError:
        return True
    last_change = time.time()
    while time.time() - start < timeout:
        time.sleep(0.2)
        try:
            cur = os.stat(p).st_size
        except FileNotFoundError:
            return True
        if cur != last:
            last = cur
            last_change = time.time()
        else:
            if time.time() - last_change >= stable_secs:
                return True
    return False

def unique_destination(path: Path) -> Path:
    """Return a unique file path by adding (n) if needed."""
    if not path.exists():
        return path
    stem, suffix = path.stem, path.suffix
    parent = path.parent
    i = 1
    while True:
        candidate = parent / f"{stem} ({i}){suffix}"
        if not candidate.exists():
            return candidate
        i += 1

def download_watcher_polling(
    stop_event: threading.Event,
    window: "webview.Window",
    _storage_dir: Path,
    watch_dir: Path
):
    """Watch a directory for new downloads and handle save/move dialogs."""
    seen = list_finished(watch_dir)
    print(f"[positron] polling watching {watch_dir}")

    delay = 0.5
    min_delay, max_delay = 0.5, 4.0  # pylint: disable=invalid-name

    def confirm_overwrite(path: Path) -> bool:
        """Ask the user if an existing file should be overwritten."""
        try:
            msg = f"File '{path.name}' already exists.\nDo you want to overwrite it?"
            res = window.create_confirmation_dialog("Overwrite file?", msg)
            return bool(res)
        except Exception as e:  # pylint: disable=broad-exception-caught
            print(f"[positron] overwrite confirm dialog error: {e}")
            return False

    while not stop_event.is_set():
        try:
            current = list_finished(watch_dir)
            new = current - seen
            if new:
                delay = min_delay
                for fname in sorted(new):
                    src = watch_dir / fname
                    wait_file_stable(src, stable_secs=0.8, timeout=300.0)

                    dst = choose_save_as(window, default_name=fname, start_dir=watch_dir)
                    if not dst:
                        try:
                            src.unlink()
                            print(f"[positron] User cancelled -> deleted {src}")
                        except Exception as e:  # pylint: disable=broad-exception-caught
                            print(f"[positron] Cannot delete cancelled file {src}: {e}")
                        continue

                    if dst.exists() and dst.is_dir():
                        dst = dst / fname

                    if dst.exists():
                        if confirm_overwrite(dst):
                            try:
                                dst.unlink()
                                print(f"[positron] Overwriting {dst}")
                            except Exception as e:  # pylint: disable=broad-exception-caught
                                print(f"[positron] Cannot remove existing {dst}: {e}")
                                dst = unique_destination(dst)
                        else:
                            dst = unique_destination(dst)

                    try:
                        dst.parent.mkdir(parents=True, exist_ok=True)
                        shutil.move(str(src), str(dst))
                        print(f"[positron] Moved {fname} -> {dst}")
                    except Exception as e:  # pylint: disable=broad-exception-caught
                        print(f"[positron] Move failed: {e}")
                seen = current
            else:
                delay = min(max_delay, delay * 1.3)
            time.sleep(delay)
        except Exception as e:  # pylint: disable=broad-exception-caught
            print(f"[positron] polling watcher error: {e}")
            time.sleep(1.0)

# ----------------- main -------------------------------------------------------
def main():
    """Main entry point for the Positron runner."""
    global _LAST_STORAGE_DIR  # pylint: disable=global-statement

    ap = argparse.ArgumentParser(description="Positron runner")
    ap.add_argument("--gui", help="GUI backend (gtk/qt/edgechromium/mshtml/cocoa)")
    ap.add_argument("--debug", action="store_true", help="Enable pywebview debug logging")
    ap.add_argument("--size", type=parse_size, help="Window size: WIDTHxHEIGHT")
    ap.add_argument("--min-size", dest="min_size",
                    type=parse_size, help="Minimum size: WIDTHxHEIGHT")
    ap.add_argument("--pos", type=parse_pos, help="Initial position: X,Y")
    ap.add_argument("--fullscreen", action="store_true", help="Start fullscreen")
    ap.add_argument("--fixed", action="store_true", help="Non-resizable window")
    ap.add_argument("--watch-dir", help="Directory to watch for completed downloads (override)")
    ap.add_argument("--profile-dir", help="Override storage root directory")
    args = ap.parse_args()

    base_dir = Path(__file__).resolve().parent
    www_dir = base_dir / "www"
    www_dir.mkdir(exist_ok=True)
    ensure_default_index(www_dir)

    try:
        httpd = start_http_server(www_dir, HOST, PORT)
    except OSError as e:
        print(f"Error: cannot start server on {HOST}:{PORT} — {e}")
        sys.exit(1)
    if not wait_for_server(HOST, PORT, timeout=5.0):
        print("Error: server not reachable after startup.")
        sys.exit(1)

    bundle_title = os.environ.get("POSITRON_TITLE") or Path(sys.argv[0]).stem or "Positron"
    env_profile = os.environ.get("POSITRON_PROFILE_DIR")
    if args.profile_dir:
        storage_dir = Path(args.profile_dir).expanduser()
    elif env_profile:
        storage_dir = Path(env_profile).expanduser()
    else:
        storage_dir = Path.home() / ".positron" / bundle_title
    storage_dir.mkdir(parents=True, exist_ok=True)
    _LAST_STORAGE_DIR = storage_dir

    win_kwargs = {}
    if args.size:
        win_kwargs["width"], win_kwargs["height"] = args.size
    if args.min_size:
        win_kwargs["min_size"] = args.min_size
    if args.pos:
        win_kwargs["x"], win_kwargs["y"] = args.pos
    if args.fullscreen:
        win_kwargs["fullscreen"] = True
    if args.fixed:
        win_kwargs["resizable"] = False

    def pick_default_gui():
        """Pick default GUI backend based on platform."""
        if sys.platform.startswith("linux"):
            return "gtk"
        if sys.platform == "darwin":
            return "cocoa"
        if sys.platform.startswith("win"):
            return "edgechromium"
        return None

    selected_gui = args.gui or pick_default_gui()
    print(f"[positron] backend target: {selected_gui or 'auto'} | storage_path={storage_dir}")

    h = (www_dir / "index.html").stat().st_size
    url = f"http://{HOST}:{PORT}/index.html?{h}"
    window = webview.create_window(bundle_title, url, **win_kwargs)

    try:
        _setup_persistence(selected_gui, window, storage_dir)
    except Exception as e:  # pylint: disable=broad-exception-caught
        print(f"[positron] early persistence setup skipped: {e}")

    watch_dir = Path(args.watch_dir).expanduser() if args.watch_dir else detect_download_dir()
    stop_event = threading.Event()
    t = threading.Thread(
        target=download_watcher_polling,
        args=(stop_event, window, storage_dir, watch_dir),
        daemon=True,
    )
    print("[positron] watcher mode: polling")
    t.start()

    try:
        webview.start(
            on_loaded,
            window,
            debug=args.debug,
            private_mode=False,
            storage_path=str(storage_dir),
            gui=selected_gui,
        )
    finally:
        stop_event.set()
        httpd.shutdown()
        httpd.server_close()


if __name__ == "__main__":
    main()
